<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>시간표형 타임 트래커</title>
    <!-- Google Fonts - Inter 폰트 추가 (깔끔하면서도 귀여운 느낌) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS 변수 정의 - somnote 디자인에서 영감 */
        :root {
            --main-bg-color: #f0f4f8; /* 전체 배경색 (아주 연한 파란색 계열 회색) */
            --card-bg-color: #ffffff; /* 카드/컨테이너 배경색 */
            --header-bg-color: #e3f2fd; /* 헤더 배경색 (더 밝은 하늘색) */
            --cell-bg-color: #ffffff; /* 일반 셀 배경색 (흰색) */
            --cell-border-color: #c5e1f7; /* 셀 테두리색 (약간 진한 연한 하늘색) */
            --input-border-color: #bbdefb; /* 입력 필드 테두리색 (연한 파란색) */
            --text-color: #34495e; /* 기본 텍스트 색상 (짙은 파란색 계열) */
            --placeholder-color: #95a5a6; /* 플레이스홀더 텍스트 색상 */

            /* 버튼 색상 */
            --button-primary-bg: #64b5f6; /* 메인 버튼 하늘색 */
            --button-primary-hover: #42a5f5; /* 메인 버튼 호버 하늘색 */
            --button-confirm-bg: #81c784; /* 확인 버튼 (연한 초록색) */
            --button-confirm-hover: #66bb6a; /* 확인 버튼 호버 */
            --button-cancel-bg: #bdbdbd; /* 취소 버튼 (회색) */
            --button-cancel-hover: #a0a0a0; /* 취소 버튼 호버 */
            --button-delete-bg: #ef5350; /* 삭제 버튼 (연한 빨간색) */
            --button-delete-hover: #e53935; /* 삭제 버튼 호버 */

            /* 그림자 및 둥근 모서리 */
            --border-radius-sm: 4px; /* 더 작게 */
            --border-radius-md: 8px; /* 더 작게 */
            --border-radius-lg: 12px; /* 더 작게 */
            --box-shadow-light: 0 3px 6px rgba(0, 0, 0, 0.05); /* 더 부드럽고 얕은 그림자 */
            --box-shadow-medium: 0 5px 10px rgba(0, 0, 0, 0.08);
        }

        /* 기본 바디 스타일 */
        body {
            font-family: 'Inter', sans-serif; /* Apply Inter font */
            background-color: var(--main-bg-color); /* Background color */
            color: var(--text-color); /* Default text color */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px; /* Reduced padding */
            margin: 0;
            overflow-x: hidden; /* Prevent horizontal scroll */
            min-height: 100vh; /* Set minimum height */
            box-sizing: border-box;
        }

        /* Container style (wraps the entire app) */
        .container {
            width: 100%; /* Set width to 100% for responsiveness */
            max-width: 450px; /* Adjusted max-width for new elements */
            background-color: var(--card-bg-color);
            border-radius: var(--border-radius-lg); /* Rounded corners */
            box-shadow: var(--box-shadow-light); /* Soft shadow */
            padding: 8px; /* Reduced padding */
            box-sizing: border-box; /* Include padding in width calculation */
            margin-bottom: 8px; /* Reduced margin between input UI and timetable */
        }

        /* Input UI style */
        .input-ui {
            width: 100%; /* Set width to 100% for responsiveness */
            max-width: 450px; /* Adjusted max-width for new elements */
            background-color: var(--card-bg-color);
            padding: 8px; /* Reduced padding */
            border-radius: var(--border-radius-lg); /* Rounded box */
            box-shadow: var(--box-shadow-light); /* Soft shadow */
            margin-bottom: 5px; /* Reduced margin to 5px */
            display: flex;
            flex-wrap: wrap; /* Allow elements to wrap to the next line */
            align-items: center;
            justify-content: flex-start; /* Align to the left */
            gap: 4px; /* Reduced gap between elements */
            box-sizing: border-box;
            overflow-x: hidden; /* Shrink instead of showing scrollbar if content overflows */
            padding-bottom: 4px; /* Space for scrollbar (even if hidden) */
        }

        .input-ui input[type="text"],
        .input-ui select {
            padding: 5px 6px; /* Reduced padding */
            border: 1px solid var(--input-border-color);
            border-radius: var(--border-radius-sm); /* Rounded corners */
            font-size: 11px; /* Reduced font size */
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            flex-grow: 1; /* Allow to grow flexibly */
            min-width: 50px; /* Reduced min-width */
        }

        .input-ui input[type="text"] {
            flex-basis: 80px; /* Reduced base width */
        }

        .input-ui select {
            flex-basis: 40px; /* Reduced base width */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%204%205%22%3E%3Cpath%20fill%3D%22%23333%22%20d%3D%22M2%200L0%202h4zm0%205L0%203h4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7em top 50%, 0 0;
            background-size: 0.65em auto, 100%;
        }

        .input-ui input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            width: 24px; /* Reduced size */
            height: 24px; /* Reduced size */
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            padding: 0;
            background: none;
            position: relative; /* Base for popup position */
            z-index: 100; /* Display above other elements */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .input-ui input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .input-ui input[type="color"]::-webkit-color-swatch {
            border: 1px solid var(--input-border-color);
            border-radius: var(--border-radius-sm);
        }

        .input-ui button {
            background-color: var(--button-primary-bg);
            color: white;
            padding: 5px 10px; /* Reduced padding */
            border: none;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: 11px; /* Reduced font size */
            font-weight: bold;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Button shadow */
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.1s ease;
            flex-shrink: 0;
        }

        .input-ui button:hover {
            background-color: var(--button-primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .input-ui button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Add color to palette button (the small '+' button) */
        .add-color-to-palette-button {
            background-color: var(--button-confirm-bg); /* Greenish color for add */
            color: white;
            width: 24px; /* Match color input size */
            height: 24px; /* Match color input size */
            padding: 0; /* No padding */
            border: none;
            border-radius: 50%; /* Circular button */
            cursor: pointer;
            font-size: 14px; /* Larger '+' symbol */
            font-weight: bold;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.1s ease;
            display: flex; /* Center the '+' */
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        .add-color-to-palette-button:hover {
            background-color: var(--button-confirm-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .add-color-to-palette-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Favorite Colors Section */
        .favorite-colors-section {
            width: 100%;
            max-width: 450px; /* Adjusted max-width */
            background-color: var(--card-bg-color);
            padding: 4px 8px; /* Reduced vertical padding, kept horizontal */
            border-radius: var(--border-radius-lg);
            box-shadow: var(--box-shadow-light);
            margin-top: 5px; /* Reduced margin to 5px */
            margin-bottom: 10px; /* Reduced margin */
            box-sizing: border-box;
            display: flex; /* Use flexbox for internal layout */
            flex-direction: row; /* Align horizontally */
            align-items: center; /* Center items vertically */
            justify-content: center; /* Center content */
            min-height: 30px; /* Set a fixed minimum height */
            max-height: 30px; /* Set a fixed maximum height */
            overflow: hidden; /* Hide overflow if swatches exceed height */
        }

        /* Removed h4 styles as the title is removed */
        /*
        .favorite-colors-section h4 {
            margin-top: 0;
            margin-bottom: 4px;
            color: var(--text-color);
            font-size: 11px;
            text-align: center;
        }
        */

        .favorite-colors-palette {
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping to keep it thin */
            gap: 4px; /* Reduced gap between color swatches */
            justify-content: center; /* Center the swatches */
            padding: 0; /* No padding */
            min-height: auto; /* Let content define height */
            max-height: none; /* Let content define height */
            overflow-x: auto; /* Allow horizontal scroll if many colors */
            overflow-y: hidden;
            align-items: center; /* Vertically center swatches */
            flex-grow: 1; /* Allow palette to grow */
            margin: 0 5px; /* Small horizontal margin */
        }

        .favorite-colors-palette::-webkit-scrollbar {
            height: 4px; /* Thin scrollbar */
        }

        .favorite-colors-palette::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .color-swatch {
            width: 18px; /* Reduced size of color swatch */
            height: 18px; /* Reduced size of color swatch */
            border-radius: 50%; /* Make it circular */
            border: 1px solid var(--input-border-color);
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .color-swatch:hover {
            transform: scale(1.1); /* Slightly enlarge on hover */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Removed add-to-palette-button specific styles as it's now integrated */
        /*
        .add-to-palette-button {
            background-color: var(--button-confirm-bg);
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.1s ease;
            margin-top: 6px;
            display: block;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        .add-to-palette-button:hover {
            background-color: var(--button-confirm-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .add-to-palette-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        */


        /* Timetable container style */
        .time-table-container {
            position: relative;
            width: 100%;
            max-width: 450px; /* Adjusted max-width */
            border-radius: var(--border-radius-lg);
            overflow-x: hidden; /* Shrink instead of showing scrollbar if content overflows */
            overflow-y: hidden;
            box-shadow: var(--box-shadow-light);
            background-color: var(--card-bg-color);
        }

        /* Timetable grid style */
        .time-table {
            display: grid;
            /* First column for hour labels (25px fixed), remaining 12 columns for minutes (flexible) */
            grid-template-columns: 25px repeat(12, 1fr); /* Reduced hour column width */
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
        }

        /* Common style for timetable cells */
        .time-table-cell {
            height: 25px; /* Reduced cell height */
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            border: 1px solid var(--cell-border-color);
            font-size: 10px; /* Reduced font size */
            color: var(--text-color);
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflowing text */
            text-overflow: ellipsis; /* Show ellipsis for overflowing text */
        }

        /* Minute header cell style */
        .header-minute-cell {
            background-color: var(--header-bg-color);
            font-weight: bold;
        }

        /* Hour header cell style */
        .header-hour-cell {
            background-color: var(--header-bg-color);
            font-weight: bold;
        }

        /* Regular time cell background */
        .time-cell {
            background-color: var(--cell-bg-color);
        }

        /* Schedule block style */
        .schedule-block {
            position: absolute;
            /* Default color reflects somnote's pastel tone */
            background-color: #a2d2ff; /* Light blue */
            border-radius: var(--border-radius-sm);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 10px; /* Reduced font size */
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* Schedule block shadow */
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .schedule-block:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .schedule-block.deleting {
            background-color: var(--button-delete-bg) !important; /* Red on delete */
            opacity: 0.7;
            box-shadow: none;
        }

        /* Drag preview block style */
        .drag-preview-block {
            position: absolute;
            background-color: rgba(135, 206, 235, 0.5); /* Translucent light blue */
            border: 1px dashed #87ceeb; /* Dashed border */
            border-radius: var(--border-radius-sm);
            z-index: 5;
            pointer-events: none;
        }

        /* Custom modal style */
        .custom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .custom-modal-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        .custom-modal-content {
            background-color: var(--card-bg-color);
            padding: 15px; /* Reduced padding */
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-medium);
            text-align: center;
            max-width: 220px; /* Reduced max-width */
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
            font-family: 'Inter', sans-serif;
        }

        .custom-modal-overlay.visible .custom-modal-content {
            transform: translateY(0);
        }

        .custom-modal-content h3 {
            margin-top: 0;
            color: var(--text-color);
            font-size: 1em; /* Reduced font size */
            margin-bottom: 8px; /* Reduced margin */
        }

        .custom-modal-content p {
            color: var(--text-color);
            margin-bottom: 12px; /* Reduced margin */
            line-height: 1.2; /* Adjusted line height */
            font-size: 0.85em; /* Reduced font size */
        }

        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 6px; /* Reduced gap */
        }

        .custom-modal-buttons button {
            padding: 6px 12px; /* Reduced padding */
            border: none;
            border-radius: var(--border-radius-sm);
            font-size: 12px; /* Reduced font size */
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            font-family: 'Inter', sans-serif;
        }

        .custom-modal-buttons button.confirm-btn {
            background-color: var(--button-delete-bg); /* Delete button color */
            color: white;
        }

        .custom-modal-buttons button.confirm-btn:hover {
            background-color: var(--button-delete-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .custom-modal-buttons button.cancel-btn {
            background-color: var(--button-cancel-bg);
            color: white;
        }

        .custom-modal-buttons button.cancel-btn:hover {
            background-color: var(--button-cancel-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Custom alert message box style */
        .custom-alert-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-bg-color);
            padding: 15px; /* Reduced padding */
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-medium);
            text-align: center;
            z-index: 1001;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease, transform 0.3s ease;
            font-family: 'Inter', sans-serif;
            max-width: 220px; /* Reduced max-width */
            width: 90%;
        }

        .custom-alert-box.visible {
            visibility: visible;
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .custom-alert-box p {
            margin-bottom: 10px; /* Reduced margin */
            color: var(--text-color);
            font-size: 0.9em; /* Reduced font size */
        }

        .custom-alert-box button {
            background-color: var(--button-primary-bg);
            color: white;
            padding: 6px 12px; /* Reduced padding */
            border: none;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: 12px; /* Reduced font size */
            font-weight: bold;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.1s ease;
        }

        .custom-alert-box button:hover {
            background-color: var(--button-primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .custom-alert-box button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Responsive design (adjust input UI on small screens) */
        @media (max-width: 450px) { /* Adjust for very small screens, e.g., mobile portrait */
            body {
                padding: 5px; /* Even smaller body padding */
            }
            .input-ui {
                flex-direction: column; /* Stack vertically */
                align-items: stretch; /* Take full width */
                flex-wrap: wrap; 
                padding: 6px; /* Reduced input-ui padding */
                gap: 3px; /* Reduced input-ui gap */
                margin-bottom: 5px; /* Ensure consistency for responsive */
            }
            .input-ui input[type="text"],
            .input-ui select,
            .input-ui input[type="color"],
            .input-ui button,
            .add-color-to-palette-button { /* Apply to new button too */
                width: 100%; /* Full width */
                margin-bottom: 5px; /* Reduced bottom margin */
                flex-basis: auto; /* Maintain flexibility */
            }
            .input-ui button {
                margin-top: 3px; /* Top margin for buttons */
            }
            .input-ui span { /* Center ~ symbol */
                text-align: center;
                width: 100%;
            }
            .favorite-colors-section {
                padding: 3px 5px; /* Even more reduced padding for favorite colors section */
                min-height: 25px; /* Adjusted min-height for smaller screens */
                max-height: 25px; /* Adjusted max-height for smaller screens */
                margin-top: 5px; /* Ensure consistency for responsive */
            }
            .favorite-colors-palette {
                gap: 2px; /* Even more reduced gap for swatches */
            }
            .color-swatch {
                width: 14px; /* Even smaller swatches */
                height: 14px; /* Even smaller swatches */
            }
            .add-color-to-palette-button {
                padding: 2px 4px; /* Even smaller button */
                font-size: 8px; /* Even smaller font */
                width: 20px; /* Adjusted width for smaller screens */
                height: 20px; /* Adjusted height for smaller screens */
            }
            .time-table-cell {
                height: 20px; /* Even smaller cell height */
                font-size: 9px; /* Even smaller font size */
            }
            .schedule-block {
                font-size: 9px; /* Even smaller font size */
            }
        }
    </style>
</head>
<body>
    <!-- Input UI Section -->
    <div class="input-ui">
        <input type="text" id="activityName" placeholder="활동명">
        <select id="startTimeHour"></select>
        <select id="startTimeMinute"></select>
        <span style="color: var(--text-color); font-weight: bold;">~</span> <!-- Time separator added -->
        <select id="endTimeHour"></select>
        <select id="endTimeMinute"></select>
        <input type="color" id="blockColor" value="#a2d2ff"> <!-- Default light blue color from somnote example -->
        <button class="add-color-to-palette-button" id="addToPaletteButton">+</button> <!-- New '+' button -->
        <button id="addActivity">추가</button>
        <select id="dayOfWeekSelect"></select> <!-- Day of week selection dropdown added -->
    </div>

    <!-- Favorite Colors Section -->
    <div class="favorite-colors-section">
        <div class="favorite-colors-palette" id="favoriteColorsPalette">
            <!-- Favorite color swatches will be rendered here by JavaScript -->
        </div>
    </div>

    <!-- Timetable Container Section -->
    <div class="time-table-container" id="timeTableContainer">
        <div class="time-table" id="timeTable">
            <!-- Minute header row (generated by JavaScript, except for the first empty cell) -->
            <div class="time-table-cell header-minute-cell" style="background-color: var(--card-bg-color); border: none;"></div>
            <div class="time-table-cell header-minute-cell">05</div>
            <div class="time-table-cell header-minute-cell">10</div>
            <div class="time-table-cell header-minute-cell">15</div>
            <div class="time-table-cell header-minute-cell">20</div>
            <div class="time-table-cell header-minute-cell">25</div>
            <div class="time-table-cell header-minute-cell">30</div>
            <div class="time-table-cell header-minute-cell">35</div>
            <div class="time-table-cell header-minute-cell">40</div>
            <div class="time-table-cell header-minute-cell">45</div>
            <div class="time-table-cell header-minute-cell">50</div>
            <div class="time-table-cell header-minute-cell">55</div>
            <div class="time-table-cell header-minute-cell">60</div>
            <!-- Hour cells will be generated by JavaScript -->
        </div>
    </div>

    <!-- Custom Delete Confirmation Modal -->
    <div class="custom-modal-overlay" id="deleteConfirmModal">
        <div class="custom-modal-content">
            <h3 id="modalActivityName"></h3>
            <p>이 활동을 정말 삭제하시겠습니까?</p>
            <div class="custom-modal-buttons">
                <button class="confirm-btn" id="confirmDeleteBtn">삭제</button>
                <button class="cancel-btn" id="cancelDeleteBtn">취소</button>
            </div>
        </div>
    </div>

    <!-- Custom Alert Message Box -->
    <div class="custom-alert-box" id="customAlertBox">
        <p id="customAlertMessage"></p>
        <button id="customAlertCloseBtn">확인</button>
    </div>

    <script>
        // DOM element references
        const timeTable = document.getElementById('timeTable');
        const timeTableContainer = document.getElementById('timeTableContainer');
        const activityNameInput = document.getElementById('activityName');
        const startTimeHourSelect = document.getElementById('startTimeHour');
        const startTimeMinuteSelect = document.getElementById('startTimeMinute');
        const endTimeHourSelect = document.getElementById('endTimeHour');
        const endTimeMinuteSelect = document.getElementById('endTimeMinute');
        const blockColorInput = document.getElementById('blockColor');
        const addActivityButton = document.getElementById('addActivity');
        const dayOfWeekSelect = document.getElementById('dayOfWeekSelect'); // Day of week selection dropdown

        // Favorite colors DOM elements
        const favoriteColorsPalette = document.getElementById('favoriteColorsPalette');
        const addToPaletteButton = document.getElementById('addToPaletteButton'); // Now the '+' button

        // Modal related DOM element references
        const deleteConfirmModal = document.getElementById('deleteConfirmModal');
        const modalActivityName = document.getElementById('modalActivityName');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');

        // Alert message box related DOM element references
        const customAlertBox = document.getElementById('customAlertBox');
        const customAlertMessage = document.getElementById('customAlertMessage');
        const customAlertCloseBtn = document.getElementById('customAlertCloseBtn');

        let blockToDelete = null; // Variable to store the block element to be deleted

        // Drag related variables
        let isDragging = false;
        let dragStartCellData = null; // { hour, minute, col, row }
        let currentDragElement = null; // Temporary block DOM element displayed during drag

        // Constants definition
        const CELL_HEIGHT = 25; // Reduced cell height
        const MINUTES_IN_HOUR = 60; // 1 hour is 60 minutes
        const MINUTES_PER_CELL = 5; // Each cell represents 5 minutes
        const CELLS_PER_HOUR = MINUTES_IN_HOUR / MINUTES_PER_CELL; // Number of minute cells per hour (12)
        const TOTAL_HOURS = 24; // Total 24 hours
        const START_DISPLAY_HOUR = 6; // Timetable start hour (6 AM)
        const LOCAL_STORAGE_ACTIVITIES_KEY = 'timeTrackerActivities'; // Local storage key for activities
        const LOCAL_STORAGE_COLORS_KEY = 'timeTrackerFavoriteColors'; // Local storage key for favorite colors

        // Days of the week array (starting from Monday)
        const daysOfWeek = ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'];
        let selectedDayIndex = new Date().getDay(); // 0:Sun, 1:Mon, ..., 6:Sat
        if (selectedDayIndex === 0) selectedDayIndex = 6; // Sunday is 6 (last day)
        else selectedDayIndex--; // Adjust to 0:Mon, 1:Tue, ... 5:Sat, 6:Sun

        // Object to store activities for all days (in-memory)
        // Example: { '0': [{...}, {...}], '1': [{...}], ... }
        let allActivities = {}; 
        daysOfWeek.forEach((_, index) => {
            allActivities[index] = []; // Initialize an empty array for each day
        });

        // Array to store favorite color hex codes
        let favoriteColors = [];

        // Dynamically calculated cell width
        let dynamicCellWidth = 0;

        /**
         * Calculates and updates the width of cells based on the current timetable container width.
         * This function is called on initial load and when the container size changes.
         */
        function updateCellDimensions() {
            // Get the actual computed width of the first column (hour column)
            const firstColumnHeader = timeTable.querySelector('.header-hour-cell');
            let actualHourColumnWidth = 25; // Default fallback if element not found or has no width

            if (firstColumnHeader) {
                actualHourColumnWidth = firstColumnHeader.offsetWidth;
            }

            // Calculate the total width available for the 12 minute cells
            const availableWidthForMinuteCells = timeTable.clientWidth - actualHourColumnWidth;
            dynamicCellWidth = availableWidthForMinuteCells / CELLS_PER_HOUR;

            // Ensure dynamicCellWidth doesn't become negative or too small
            if (dynamicCellWidth <= 0) {
                dynamicCellWidth = 1; // Prevent division by zero or negative width, ensure at least 1px
            }

            console.log(`[updateCellDimensions] timeTable.clientWidth: ${timeTable.clientWidth}, actualHourColumnWidth: ${actualHourColumnWidth}, dynamicCellWidth: ${dynamicCellWidth}`);
            renderActivitiesForSelectedDay(); // Recalculate positions
        }

        // --- Local Storage Functions for Activities ---
        /**
         * Saves all current activity data to local storage.
         */
        function saveActivities() {
            try {
                localStorage.setItem(LOCAL_STORAGE_ACTIVITIES_KEY, JSON.stringify(allActivities));
                console.log('[saveActivities] Activities saved to local storage.');
            } catch (e) {
                console.error('[saveActivities] Failed to save activities to local storage:', e);
                showAlert('활동 저장에 실패했습니다. 브라우저 저장 공간을 확인해주세요.');
            }
        }

        /**
         * Loads activity data from local storage.
         * @returns {Object} Loaded activity data or an empty object
         */
        function loadActivities() {
            try {
                const storedActivities = localStorage.getItem(LOCAL_STORAGE_ACTIVITIES_KEY);
                if (storedActivities) {
                    const parsedActivities = JSON.parse(storedActivities);
                    // Ensure all days are initialized even if not present in stored data
                    daysOfWeek.forEach((_, index) => {
                        if (!parsedActivities[index]) {
                            parsedActivities[index] = [];
                        }
                    });
                    console.log('[loadActivities] Activities loaded from local storage:', parsedActivities);
                    return parsedActivities;
                }
            } catch (e) {
                console.error('[loadActivities] Failed to load activities from local storage:', e);
                showAlert('활동 불러오기에 실패했습니다. 데이터가 손상되었을 수 있습니다.');
            }
            console.log('[loadActivities] No activities found in local storage, initializing empty.');
            // Return a fresh, empty structure if nothing was loaded or an error occurred
            const emptyActivities = {};
            daysOfWeek.forEach((_, index) => {
                emptyActivities[index] = [];
            });
            return emptyActivities;
        }
        // --- End Local Storage Functions for Activities ---

        // --- Local Storage Functions for Favorite Colors ---
        /**
         * Saves favorite colors to local storage.
         */
        function saveFavoriteColors() {
            try {
                localStorage.setItem(LOCAL_STORAGE_COLORS_KEY, JSON.stringify(favoriteColors));
                console.log('[saveFavoriteColors] Favorite colors saved to local storage.');
            } catch (e) {
                console.error('[saveFavoriteColors] Failed to save favorite colors to local storage:', e);
            }
        }

        /**
         * Loads favorite colors from local storage.
         */
        function loadFavoriteColors() {
            try {
                const storedColors = localStorage.getItem(LOCAL_STORAGE_COLORS_KEY);
                if (storedColors) {
                    favoriteColors = JSON.parse(storedColors);
                    console.log('[loadFavoriteColors] Favorite colors loaded:', favoriteColors);
                } else {
                    favoriteColors = []; // Initialize empty if nothing found
                }
            } catch (e) {
                console.error('[loadFavoriteColors] Failed to load favorite colors from local storage:', e);
                favoriteColors = []; // Reset on error
            }
            renderFavoriteColors(); // Render colors after loading
        }

        /**
         * Renders the favorite color swatches in the palette section.
         */
        function renderFavoriteColors() {
            favoriteColorsPalette.innerHTML = ''; // Clear existing swatches
            if (favoriteColors.length === 0) {
                favoriteColorsPalette.textContent = '아직 저장된 색상이 없습니다.';
                favoriteColorsPalette.style.color = 'var(--placeholder-color)';
                favoriteColorsPalette.style.fontSize = '10px'; /* Adjusted font size */
                favoriteColorsPalette.style.textAlign = 'center';
            } else {
                favoriteColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.classList.add('color-swatch');
                    swatch.style.backgroundColor = color;
                    swatch.dataset.color = color; // Store color value
                    swatch.title = color; // Show hex on hover
                    swatch.addEventListener('click', () => {
                        blockColorInput.value = color; // Set input color to clicked swatch color
                    });
                    favoriteColorsPalette.appendChild(swatch);
                });
            }
        }

        /**
         * Adds the currently selected color to the favorite colors palette.
         */
        addToPaletteButton.addEventListener('click', () => {
            const currentColor = blockColorInput.value.toLowerCase(); // Convert to lowercase for consistent comparison
            if (!favoriteColors.includes(currentColor)) {
                favoriteColors.push(currentColor);
                saveFavoriteColors();
                renderFavoriteColors();
                showAlert('색상이 팔레트에 추가되었습니다.');
            } else {
                showAlert('이미 팔레트에 있는 색상입니다.');
            }
        });
        // --- End Local Storage Functions for Favorite Colors ---


        // Function to display custom alert message
        function showAlert(message) {
            customAlertMessage.textContent = message;
            customAlertBox.classList.add('visible');
        }

        // Event listener for closing custom alert message
        customAlertCloseBtn.addEventListener('click', () => {
            customAlertBox.classList.remove('visible');
        });

        // Function to populate time/minute selection dropdowns
        function populateTimeSelects() {
            // Hours (from 06:00 to 05:55 the next day -> 06 to 29)
            for (let i = START_DISPLAY_HOUR; i < START_DISPLAY_HOUR + TOTAL_HOURS; i++) {
                const displayHour = i.toString().padStart(2, '0'); // 06, 07, ..., 23, 24, 25, ..., 29
                
                const startOpt = document.createElement('option');
                startOpt.value = i;
                startOpt.textContent = displayHour;
                startTimeHourSelect.appendChild(startOpt);

                const endOpt = document.createElement('option');
                endOpt.value = i;
                endOpt.textContent = displayHour;
                endTimeHourSelect.appendChild(endOpt);
            }

            // Minutes (from 00 to 55)
            for (let i = 0; i < MINUTES_IN_HOUR; i += MINUTES_PER_CELL) {
                const minute = i.toString().padStart(2, '0');
                const startOpt = document.createElement('option');
                startOpt.value = i;
                startOpt.textContent = minute;
                startTimeMinuteSelect.appendChild(startOpt);

                const endOpt = document.createElement('option');
                endOpt.value = i;
                endOpt.textContent = minute;
                endTimeMinuteSelect.appendChild(endOpt);
            }
        }

        // Function to populate day of week selection dropdown
        function populateDayOfWeekSelect() {
            dayOfWeekSelect.innerHTML = ''; // Clear existing options
            daysOfWeek.forEach((day, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = day;
                dayOfWeekSelect.appendChild(option);
            });
            dayOfWeekSelect.value = selectedDayIndex; // Set to current day
        }


        // Function to create the timetable grid
        function createTimeTable() {
            // From 6 AM to 5:55 AM the next day (total 24 hours)
            // So, hours are from 6 to 29 (5 AM the next day)
            for (let h = START_DISPLAY_HOUR; h < START_DISPLAY_HOUR + TOTAL_HOURS; h++) {
                const displayHour = h % 24; // Hours >= 24 are displayed as 00, 01, etc.
                const hourCell = document.createElement('div');
                hourCell.classList.add('time-table-cell', 'header-hour-cell');
                hourCell.textContent = displayHour.toString().padStart(2, '0');
                timeTable.appendChild(hourCell);

                for (let m = 0; m < MINUTES_IN_HOUR; m += MINUTES_PER_CELL) {
                    const cell = document.createElement('div');
                    cell.classList.add('time-table-cell', 'time-cell');
                    cell.dataset.hour = h; // Store actual hour value (6-29)
                    cell.dataset.minute = m; // Store actual minute value (0, 5, ..., 55)
                    timeTable.appendChild(cell);
                }
            }
        }

        // Helper function to convert time (hour, minute) to total minutes
        function timeToTotalMinutes(hour, minute) {
            return (hour * MINUTES_IN_HOUR) + minute;
        }

        /**
         * Renders a single activity block on the timetable.
         * This function is called by `renderActivitiesForSelectedDay`.
         */
        function renderSingleActivityBlock(activityData, activityIndexInArray) {
            let currentStartMinutes = timeToTotalMinutes(activityData.startHour, activityData.startMinute);
            let finalEndMinutes = timeToTotalMinutes(activityData.endHour, activityData.endMinute);

            // Split activities into 1-hour segments or remaining time segments
            while (currentStartMinutes < finalEndMinutes) {
                const segmentStartHour = Math.floor(currentStartMinutes / MINUTES_IN_HOUR);
                const segmentStartMinute = currentStartMinutes % MINUTES_IN_HOUR;

                // Choose the earlier of the end of the current hour segment (e.g., 09:55 + 5 min = 10:00)
                // or the final end time of the activity
                let segmentEndMinutes = Math.min(
                    finalEndMinutes,
                    timeToTotalMinutes(segmentStartHour, 55) + MINUTES_PER_CELL
                );

                const segmentDurationMinutes = segmentEndMinutes - currentStartMinutes;

                if (segmentDurationMinutes <= 0) {
                    currentStartMinutes = segmentEndMinutes;
                    continue;
                }

                const segmentStartCellIndexInHour = segmentStartMinute / MINUTES_PER_CELL;
                const segmentDurationCells = segmentDurationMinutes / MINUTES_PER_CELL;

                const row = (segmentStartHour - START_DISPLAY_HOUR); // Row index on the timetable (0-based)

                // Do not render blocks outside the timetable display range
                if (row < 0 || row >= TOTAL_HOURS) {
                    currentStartMinutes = segmentEndMinutes;
                    continue;
                }

                const block = document.createElement('div');
                block.classList.add('schedule-block');
                block.textContent = activityData.activityName;
                block.style.backgroundColor = activityData.blockColor;

                // Calculate position and size of the schedule block (using dynamic cell width)
                // Get the actual width of the first column using a query selector.
                const firstColumnHeader = timeTable.querySelector('.header-hour-cell');
                const actualHourColumnWidth = firstColumnHeader ? firstColumnHeader.offsetWidth : 25; // Fallback to 25px if not found

                block.style.left = `${actualHourColumnWidth + (segmentStartCellIndexInHour * dynamicCellWidth)}px`;
                block.style.top = `${(row + 1) * CELL_HEIGHT}px`; // +1 because of the minute header row
                block.style.width = `${segmentDurationCells * dynamicCellWidth}px`;
                block.style.height = `${CELL_HEIGHT}px`;

                console.log(`[renderSingleActivityBlock] Activity: ${activityData.activityName}, Left: ${block.style.left}, Top: ${block.style.top}, Width: ${block.style.width}, Index: ${activityIndexInArray}`);

                // Store data attributes (used for deletion confirmation, etc.)
                block.dataset.originalActivityName = activityData.activityName;
                block.dataset.originalStartHour = activityData.startHour;
                block.dataset.originalStartMinute = activityData.startMinute;
                block.dataset.originalEndHour = activityData.endHour;
                block.dataset.originalEndMinute = activityData.endMinute;
                block.dataset.blockColor = activityData.blockColor;
                block.dataset.dayOfWeek = activityData.dayOfWeek; // Add day data
                block.dataset.activityIndex = activityIndexInArray; // Store index in array (for deletion)

                // Add delete functionality: Use custom modal
                block.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent click event from propagating to parent elements
                    console.log(`[schedule-block click] Block clicked: ${block.dataset.originalActivityName}, Index: ${block.dataset.activityIndex}`);
                    blockToDelete = block; // Store the block to be deleted
                    modalActivityName.textContent = `'${block.dataset.originalActivityName}' 활동을`; // Display activity name in modal
                    deleteConfirmModal.classList.add('visible'); // Show modal
                    console.log('[schedule-block click] Delete modal should be visible.');
                });

                timeTableContainer.appendChild(block); // Add block to timetable container

                currentStartMinutes = segmentEndMinutes; // Move to the start time of the next segment
            }
        }

        /**
         * Renders activities for the currently selected day on the timetable.
         * Called when the day changes or when an activity is added/deleted.
         */
        function renderActivitiesForSelectedDay() {
            // Remove all existing timetable blocks
            document.querySelectorAll('.schedule-block').forEach(block => block.remove());

            const activitiesForCurrentDay = allActivities[selectedDayIndex] || [];
            console.log(`[renderActivitiesForSelectedDay] Rendering activities for day ${selectedDayIndex}:`, activitiesForCurrentDay);
            // Before rendering activities, re-index the array to ensure `activityIndex` is always correct.
            activitiesForCurrentDay.forEach((activity, index) => {
                renderSingleActivityBlock(activity, index);
            });
        }

        /**
         * Adds a new activity using the values from the input UI.
         * Stores activity data in the `allActivities` object and re-renders the timetable.
         */
        function addActivityBlock() {
            const activityName = activityNameInput.value.trim();
            const initialStartHour = parseInt(startTimeHourSelect.value, 10);
            const initialStartMinute = parseInt(startTimeMinuteSelect.value, 10);
            const initialEndHour = parseInt(endTimeHourSelect.value, 10);
            const initialEndMinute = parseInt(endTimeMinuteSelect.value, 10);
            const blockColor = blockColorInput.value;
            const dayOfWeek = parseInt(dayOfWeekSelect.value, 10); // Selected day index

            console.log(`[addActivityBlock] Attempting to add: ${activityName}, ${initialStartHour}:${initialStartMinute} - ${initialEndHour}:${initialEndMinute}, Day: ${daysOfWeek[dayOfWeek]}`);

            if (!activityName) {
                showAlert('활동명을 입력해주세요.');
                console.log('[addActivityBlock] Validation failed: Activity name is empty.');
                return;
            }

            let currentStartMinutes = timeToTotalMinutes(initialStartHour, initialStartMinute);
            let finalEndMinutes = timeToTotalMinutes(initialEndHour, initialEndMinute);

            if (currentStartMinutes >= finalEndMinutes) {
                showAlert('종료 시간은 시작 시간보다 늦어야 합니다.');
                console.log('[addActivityBlock] Validation failed: End time is not after start time.');
                return;
            }

            const tableStartTimeTotalMinutes = timeToTotalMinutes(START_DISPLAY_HOUR, 0);
            const tableEndTimeTotalMinutes = timeToTotalMinutes(START_DISPLAY_HOUR + TOTAL_HOURS, 0);

            if (currentStartMinutes < tableStartTimeTotalMinutes || finalEndMinutes > tableEndTimeTotalMinutes) {
                showAlert('시작 또는 종료 시간이 시간표 범위(오전 6시 ~ 다음날 오전 5시 55분)를 벗어납니다.');
                console.log(`[addActivityBlock] Validation failed: Time out of range. Start: ${currentStartMinutes}, End: ${finalEndMinutes}. Table Range: ${tableStartTimeTotalMinutes} - ${tableEndTimeTotalMinutes}`);
                return;
            }

            // Create new activity object
            const newActivity = {
                activityName,
                startHour: initialStartHour,
                startMinute: initialStartMinute,
                endHour: initialEndHour,
                endMinute: initialEndMinute,
                blockColor,
                dayOfWeek // Add day information
            };

            // Add activity to the corresponding day's array
            if (!allActivities[dayOfWeek]) {
                allActivities[dayOfWeek] = [];
            }
            allActivities[dayOfWeek].push(newActivity);
            console.log(`[addActivityBlock] Activity added for day ${dayOfWeek}:`, newActivity);
            console.log('[addActivityBlock] Current allActivities state:', allActivities);

            saveActivities(); // Save to local storage after adding activity
            renderActivitiesForSelectedDay(); // Re-render timetable for the currently selected day

            // Clear input fields
            activityNameInput.value = '';
            // blockColorInput.value = '#ff88bb'; // Reset to default color
        }

        // Modal 'Delete' button click event
        confirmDeleteBtn.addEventListener('click', () => {
            console.log('[confirmDeleteBtn click] Delete button clicked.');
            if (blockToDelete) {
                const dayToDelete = parseInt(blockToDelete.dataset.dayOfWeek, 10);
                const activityIndexToDelete = parseInt(blockToDelete.dataset.activityIndex, 10);

                console.log(`[confirmDeleteBtn click] Deleting activity: Day ${dayToDelete}, Index ${activityIndexToDelete}`);
                // Remove the activity from the `allActivities` array
                if (allActivities[dayToDelete] && allActivities[dayToDelete][activityIndexToDelete] !== undefined) { // Check for undefined
                    allActivities[dayToDelete].splice(activityIndexToDelete, 1);
                    console.log(`[confirmDeleteBtn click] Activity removed from array. New array for day ${dayToDelete}:`, allActivities[dayToDelete]);
                } else {
                    console.warn(`[confirmDeleteBtn click] Activity not found in array for deletion. Day: ${dayToDelete}, Index: ${activityIndexToDelete}`);
                }

                blockToDelete.classList.add('deleting'); // Visual effect on deletion
                setTimeout(() => {
                    blockToDelete.remove(); // Remove the block
                    blockToDelete = null; // Reset variable
                    deleteConfirmModal.classList.remove('visible'); // Hide modal
                    saveActivities(); // Save to local storage after deleting activity
                    renderActivitiesForSelectedDay(); // Re-render timetable after deletion (to prevent index issues)
                    console.log('[confirmDeleteBtn click] Activity deleted and re-rendered.');
                }, 300); // Short delay before deletion (for animation effect)
            } else {
                console.warn('[confirmDeleteBtn click] blockToDelete is null.');
            }
        });

        // Modal 'Cancel' button click event
        cancelDeleteBtn.addEventListener('click', () => {
            console.log('[cancelDeleteBtn click] Cancel button clicked.');
            blockToDelete = null; // Reset variable
            deleteConfirmModal.classList.remove('visible'); // Hide modal
        });

        // Close modal if clicking outside the modal content (optional)
        deleteConfirmModal.addEventListener('click', (event) => {
            if (event.target === deleteConfirmModal) {
                console.log('[deleteConfirmModal click] Overlay clicked, closing modal.');
                blockToDelete = null;
                deleteConfirmModal.classList.remove('visible');
            }
        });

        // --- Start Drag Functionality ---

        // Function to get cell data (hour, minute, column, row) from mouse coordinates
        function getCellDataFromCoordinates(clientX, clientY) {
            const containerRect = timeTableContainer.getBoundingClientRect();
            const relativeX = clientX - containerRect.left;
            const relativeY = clientY - containerRect.top;

            // Calculate actual cell area excluding timetable header
            const firstColumnHeader = timeTable.querySelector('.header-hour-cell');
            const actualHourColumnWidth = firstColumnHeader ? firstColumnHeader.offsetWidth : 25; // Fallback if not found

            let colIndex;
            if (relativeX < actualHourColumnWidth) {
                colIndex = 0; // Hour label column
            } else {
                colIndex = Math.floor((relativeX - actualHourColumnWidth) / dynamicCellWidth) + 1; // +1 to convert to grid column index (1-based for minute cells)
            }
            
            const rowIndex = Math.floor(relativeY / CELL_HEIGHT);

            // Check if within timetable grid bounds (excluding headers)
            if (colIndex < 1 || rowIndex < 1) { // colIndex 0 is hour label, rowIndex 0 is minute header
                return null; // Header area or outside timetable
            }

            // Calculate actual hour and minute (considering start hour and cell size)
            const hour = (rowIndex - 1) + START_DISPLAY_HOUR;
            const minute = (colIndex - 1) * MINUTES_PER_CELL;

            // Re-check if calculated hour/minute is within valid timetable range
            if (hour >= START_DISPLAY_HOUR && hour < START_DISPLAY_HOUR + TOTAL_HOURS &&
                minute >= 0 && minute < MINUTES_IN_HOUR) {
                return { hour, minute, col: colIndex, row: rowIndex };
            }
            return null;
        }

        // Mouse down event handler
        timeTableContainer.addEventListener('mousedown', (e) => {
            // Allow only left mouse button
            if (e.button !== 0) return;

            // Do not start drag if a schedule-block is clicked (to avoid conflict with delete function)
            if (e.target.classList.contains('schedule-block')) {
                return;
            }

            // Start drag only on timetable cells
            const startCellData = getCellDataFromCoordinates(e.clientX, e.clientY);
            if (!startCellData) {
                return;
            }

            isDragging = true;
            dragStartCellData = startCellData;

            // Create temporary drag preview block
            currentDragElement = document.createElement('div');
            currentDragElement.classList.add('drag-preview-block');
            // Set initial position and size (same as start cell, using dynamic cell width)
            const firstColumnHeader = timeTable.querySelector('.header-hour-cell');
            const actualHourColumnWidth = firstColumnHeader ? firstColumnHeader.offsetWidth : 25; // Fallback if not found

            currentDragElement.style.left = `${actualHourColumnWidth + ((startCellData.col - 1) * dynamicCellWidth)}px`;
            currentDragElement.style.top = `${startCellData.row * CELL_HEIGHT}px`;
            currentDragElement.style.width = `${dynamicCellWidth}px`;
            currentDragElement.style.height = `${CELL_HEIGHT}px`;
            timeTableContainer.appendChild(currentDragElement);

            // Add mousemove and mouseup event listeners to the entire document (to detect even if mouse leaves the table during drag)
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        // Mouse move event handler
        function handleMouseMove(e) {
            if (!isDragging) return;

            const currentCellData = getCellDataFromCoordinates(e.clientX, e.clientY);

            if (currentCellData) {
                // Determine actual start/end time by comparing drag start cell and current cell time data
                let effectiveStartTotalMinutes = timeToTotalMinutes(dragStartCellData.hour, dragStartCellData.minute);
                let effectiveEndTotalMinutes = timeToTotalMinutes(currentCellData.hour, currentCellData.minute);

                // Adjust start/end time based on drag direction
                if (effectiveEndTotalMinutes < effectiveStartTotalMinutes) {
                    [effectiveStartTotalMinutes, effectiveEndTotalMinutes] = [effectiveEndTotalMinutes, effectiveStartTotalMinutes];
                }

                // End time means the end of the selected cell, so add 5 minutes
                effectiveEndTotalMinutes += MINUTES_PER_CELL;

                const tableStartTimeTotalMinutes = timeToTotalMinutes(START_DISPLAY_HOUR, 0);

                const startCellIndex = (effectiveStartTotalMinutes - tableStartTimeTotalMinutes) / MINUTES_PER_CELL;
                const endCellIndex = (effectiveEndTotalMinutes - tableStartTimeTotalMinutes) / MINUTES_PER_CELL;

                const durationCells = endCellIndex - startCellIndex;

                if (durationCells > 0) {
                    const startHourForDisplay = Math.floor(effectiveStartTotalMinutes / MINUTES_IN_HOUR);
                    const startMinuteForDisplay = effectiveStartTotalMinutes % MINUTES_IN_HOUR;

                    const row = (startHourForDisplay - START_DISPLAY_HOUR);
                    const colOffset = (startMinuteForDisplay / MINUTES_PER_CELL); // Minute column index excluding hour label column

                    const firstColumnHeader = timeTable.querySelector('.header-hour-cell');
                    const actualHourColumnWidth = firstColumnHeader ? firstColumnHeader.offsetWidth : 25; // Fallback if not found

                    currentDragElement.style.left = `${actualHourColumnWidth + (colOffset * dynamicCellWidth)}px`;
                    currentDragElement.style.top = `${(row + 1) * CELL_HEIGHT}px`; // +1 because of the minute header row
                    currentDragElement.style.width = `${durationCells * dynamicCellWidth}px`;
                    currentDragElement.style.height = `${CELL_HEIGHT}px`;
                } else {
                    // If drag length is 0 or negative (less than one cell)
                    const firstColumnHeader = timeTable.querySelector('.header-hour-cell');
                    const actualHourColumnWidth = firstColumnHeader ? firstColumnHeader.offsetWidth : 25; // Fallback if not found

                    currentDragElement.style.width = `${dynamicCellWidth}px`;
                    currentDragElement.style.height = `${CELL_HEIGHT}px`;
                    currentDragElement.style.left = `${actualHourColumnWidth + ((dragStartCellData.col - 1) * dynamicCellWidth)}px`;
                    currentDragElement.style.top = `${dragStartCellData.row * CELL_HEIGHT}px`;
                }
            }
        }

        // Mouse up event handler
        function handleMouseUp(e) {
            if (!isDragging) return;

            isDragging = false;
            
            // Remove temporary drag preview block
            if (currentDragElement) {
                currentDragElement.remove();
                currentDragElement = null;
            }

            const endCellData = getCellDataFromCoordinates(e.clientX, e.clientY);

            if (dragStartCellData && endCellData) {
                let startTotalMinutes = timeToTotalMinutes(dragStartCellData.hour, dragStartCellData.minute);
                let endTotalMinutes = timeToTotalMinutes(endCellData.hour, endCellData.minute);

                // Confirm actual start/end time based on drag direction
                if (endTotalMinutes < startTotalMinutes) {
                    [startTotalMinutes, endTotalMinutes] = [endTotalMinutes, startTotalMinutes];
                }

                // End time means the end of the selected cell, so add 5 minutes
                let finalAdjustedEndMinutes = endTotalMinutes + MINUTES_PER_CELL;
                let finalAdjustedEndHour = Math.floor(finalAdjustedEndMinutes / MINUTES_IN_HOUR);
                let finalAdjustedEndMinute = finalAdjustedEndMinutes % MINUTES_IN_HOUR;

                // Populate input UI with the dragged time range
                startTimeHourSelect.value = Math.floor(startTotalMinutes / MINUTES_IN_HOUR);
                startTimeMinuteSelect.value = startTotalMinutes % MINUTES_IN_HOUR;
                endTimeHourSelect.value = finalAdjustedEndHour;
                endTimeMinuteSelect.value = finalAdjustedEndMinute;

                // Focus on activity name input field
                activityNameInput.focus();
            }

            // Remove event listeners added to the document
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            dragStartCellData = null; // Reset drag start data
        }

        // --- End Drag Functionality ---


        // Initialize function calls
        populateTimeSelects(); // Populate hour/minute dropdowns
        populateDayOfWeekSelect(); // Populate day of week dropdown
        createTimeTable(); // Create timetable grid
        
        // Use ResizeObserver to detect changes in timeTableContainer size
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target === timeTableContainer) {
                    updateCellDimensions(); // Update cell size and re-render on container size change
                }
            }
        });
        resizeObserver.observe(timeTableContainer); // Start observing timeTableContainer

        // Initial load: calculate cell size and render activities
        // Load data from local storage, then render
        allActivities = loadActivities(); 
        loadFavoriteColors(); // Load favorite colors
        updateCellDimensions(); // This call includes renderActivitiesForSelectedDay()

        // Event listener for 'Add' button click
        addActivityButton.addEventListener('click', addActivityBlock);
        // Event listener for day of week selection change
        dayOfWeekSelect.addEventListener('change', (event) => {
            selectedDayIndex = parseInt(event.target.value, 10);
            renderActivitiesForSelectedDay(); // Re-render activities when day changes
        });

        // Set initial selection values (e.g., 09:00 - 10:00)
        startTimeHourSelect.value = '9';
        startTimeMinuteSelect.value = '0';
        endTimeHourSelect.value = '10';
        endTimeMinuteSelect.value = '0';
    </script>
</body>
</html>
